<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby on Rails | Blog Rudy Lee]]></title>
  <link href="http://blog.rudylee.com/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://blog.rudylee.com/"/>
  <updated>2015-10-16T12:02:42+11:00</updated>
  <id>http://blog.rudylee.com/</id>
  <author>
    <name><![CDATA[Rudy Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Engines and Vim]]></title>
    <link href="http://blog.rudylee.com/2015/05/03/rails-engines-and-vim/"/>
    <updated>2015-05-03T16:14:00+10:00</updated>
    <id>http://blog.rudylee.com/2015/05/03/rails-engines-and-vim</id>
    <content type="html"><![CDATA[<p>At the moment, I am working on a Ruby on Rails projects using Rails Engines ( you can read more about Rails Engines here: <a href="http://guides.rubyonrails.org/engines.html">http://guides.rubyonrails.org/engines.html</a> ). In this post, I&rsquo;ll share my tips and trick on how to configure your vim to work with Rails Engines.</p>

<h1>NERDTree Bookmark</h1>

<p>I am using NERDTree Bookmark to quickly jump between different engines. If you are using NERDTree, you can create a bookmark by putting your cursor on one of the Rails Engines directory and use the command below:</p>

<p><code>
:Bookmark &lt;engine name&gt;
</code></p>

<p>After you created the bookmark, you can see the bookmarks list by pressing <code>B</code> inside NERDTree window. See the screenshot below:</p>

<p><a href="/images/vim-bookmarks.png"><img src="/images/vim-bookmarks.png" alt="" /></a></p>

<p>I also added these two options to my vimrc file.</p>

<p><code>
" Automatically show bookmarks list when you open NERDTree
let NERDTreeShowBookmarks=1
let NERDTreeChDirMode=2
</code></p>

<p><code>NERDTreeChDirMode</code> changes the current working directory of your vim to your bookmark directory. This will also enable my favourite rails.vim feature which is open alternate file.</p>

<h1>CtrlP Working Path Mode</h1>

<p>It is normal for Rails Engines to share similar directory structure and filenames. However, this creates problem when you want to search a file using CtrlP plugin. Combined with <code>NERDTreeChDirMode</code>, you can tell CtrlP to search only in the current working directory.</p>

<p>Add this option to your vimrc file to enable this feature:</p>

<p><code>
let g:ctrlp_working_path_mode = 'a'
</code></p>

<p>That&rsquo;s it for now, I&rsquo;ll update this post if I find a better workflow or configuration. If you are interested, you can check my full vimrc file here: <a href="https://github.com/rudylee/dotfiles/blob/master/vimrc">https://github.com/rudylee/dotfiles/blob/master/vimrc</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add 'current' class to website menu in Rails]]></title>
    <link href="http://blog.rudylee.com/2014/01/15/add-current-class-to-website-menu-in-rails/"/>
    <updated>2014-01-15T04:52:00+11:00</updated>
    <id>http://blog.rudylee.com/2014/01/15/add-current-class-to-website-menu-in-rails</id>
    <content type="html"><![CDATA[<p>It is common to have &lsquo;active&rsquo; state or &lsquo;current&rsquo; state on website navigation. This will help visitors to know which page they have selected.</p>

<p>This solution is based on Stackoverflow&rsquo;s question which I couldn&rsquo;t find. First, I&rsquo;ll create a method inside Rails application_helper.rb file. I&rsquo;ll call this method cp(). Here are the syntax:</p>

<p>``` ruby application_helper.rb
module ApplicationHelper
  def cp(path)</p>

<pre><code>current_route = Rails.application.routes.recognize_path(path)
"current" if current_page?(path) or params[:controller] == current_route[:controller]
</code></pre>

<p>  end
end
```</p>

<p>The method uses current_page and Rails.application.routes.recognize_path to get information about current page.</p>

<p>After that we can use it in our view. Here is the example:</p>

<p>``` ruby application.html.erb
<nav id="menu-panel"></p>

<pre><code>&lt;%= link_to 'SERVICES', services_path, class: cp('/services') %&gt;
&lt;%= link_to 'FACILITIES', facilities_path, class: cp('/facilities') %&gt;
&lt;%= link_to 'ABOUT', about_path, class: cp('/about') %&gt;
&lt;%= link_to 'CAREERS', careers_path, class: cp(careers_path) %&gt;
&lt;%= link_to 'BLOG', blog_index_path, class: cp(blog_index_path) %&gt;
&lt;%= link_to 'CONTACT', contact_path, class: cp('/contact') %&gt;
&lt;a href="#" id="close-menu-panel"&gt;&lt;b&gt;CLOSE&lt;/b&gt;&lt;/a&gt;
</code></pre>

<p></nav>
```</p>

<p>I hope that helps.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 4 CORS]]></title>
    <link href="http://blog.rudylee.com/2013/10/29/rails-4-cors/"/>
    <updated>2013-10-29T02:02:00+11:00</updated>
    <id>http://blog.rudylee.com/2013/10/29/rails-4-cors</id>
    <content type="html"><![CDATA[<h2>McFlyyy pointed out another solution to solve this problem. I haven&rsquo;t tested it myself so follow it at your own risk <a href="https://stackoverflow.com/questions/18538549/cant-get-rack-cors-working-in-rails-application/20464939#20464939">Click Here</a></h2>

<p>I was trying to use Rails to build REST API for my AngularJS app and came across CORS error on my Chrome developer tools.</p>

<p>According to <a href="http://leopard.in.ua/2012/07/08/using-cors-with-rails/">Alexey Vasiliev</a>, Cross-origin resource sharing (CORS) is a web browser technology specification which defines ways for a web server to allow its resources to be accessed by a web page from a different domain. Such access would otherwise be forbidden by the same origin policy. CORS defines a way in which the browser and the server can interact to determine whether or not to allow the cross-origin request. It is a compromise that allows greater flexibility, but is more secure than simply allowing all such requests. CORS is supported in the following browsers:</p>

<p>After following couple of outdated tutorials, I found the quick solution for it. Here are the steps:</p>

<h1>Add route to handle OPTIONS method</h1>

<p>AngularJS using OPTIONS method to check the CORS support on the API server. Thus, you need to add line in your route file to handle this. This can be done by adding code like this</p>

<p><code>ruby
match 'users', to: 'users#index', via: [:options]
resources :users
</code></p>

<p>To check whether your configuration is correct you can run &lsquo;rake routes&rsquo;. It should print out something like this:</p>

<p>``` bash
   Prefix Verb    URI Pattern               Controller#Action</p>

<pre><code>users OPTIONS /users(.:format)          users#index
      GET     /users(.:format)          users#index
      POST    /users(.:format)          users#create
</code></pre>

<p> new_user GET     /users/new(.:format)      users#new
edit_user GET     /users/:id/edit(.:format) users#edit</p>

<pre><code> user GET     /users/:id(.:format)      users#show
      PATCH   /users/:id(.:format)      users#update
      PUT     /users/:id(.:format)      users#update
      DELETE  /users/:id(.:format)      users#destroy
 root GET     /                         users#index
</code></pre>

<p>```</p>

<p>You can see on the second line, we handle OPTIONS verb and redirect to index action.</p>

<h1>Add before_filter and after_filter to allow CORS</h1>

<p>The next step is we need to return proper header to tell AngularJS that our server allow CORS. Here is the sample controller file:</p>

<p>``` ruby
UsersController &lt; ApplicationController</p>

<p>  skip_before_filter :verify_authenticity_token
  before_filter :cors_preflight_check
  after_filter :cors_set_access_control_headers</p>

<p>  # For all responses in this controller, return the CORS access control headers.
  def cors_set_access_control_headers</p>

<pre><code>headers['Access-Control-Allow-Origin'] = '*'
headers['Access-Control-Allow-Methods'] = 'POST, GET, OPTIONS'
headers['Access-Control-Max-Age'] = "1728000"
</code></pre>

<p>  end</p>

<p>  # If this is a preflight OPTIONS request, then short-circuit the
  # request, return only the necessary headers and return an empty
  # text/plain.</p>

<p>  def cors_preflight_check</p>

<pre><code>headers['Access-Control-Allow-Origin'] = '*'
headers['Access-Control-Allow-Methods'] = 'POST, GET, OPTIONS'
headers['Access-Control-Allow-Headers'] = 'X-Requested-With, X-Prototype-Version'
headers['Access-Control-Max-Age'] = '1728000'
</code></pre>

<p>  end</p>

<p>  def index</p>

<pre><code>@users = User.all

respond_to do |format|
  format.json { render :json =&gt; @users }
end
</code></pre>

<p>  end
end
```</p>

<p>We need to add skip_before_filter :verify_authenticity_token because Rails will return 422 status code and error message &lsquo;Can&rsquo;t verify CSRF token authenticity&rsquo;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zeus inside Vagrant]]></title>
    <link href="http://blog.rudylee.com/2013/09/13/zeus-inside-vagrant/"/>
    <updated>2013-09-13T00:14:00+10:00</updated>
    <id>http://blog.rudylee.com/2013/09/13/zeus-inside-vagrant</id>
    <content type="html"><![CDATA[<p>I have been using Vagrant as my development environment for the last couple weeks. It has been very helpful as I prefer to use Linux as my development environment and I can only use Windows at my workplace. With Vagrant, I can easily set up new Linux machine, install Vim plus all the plugins and completely separate development machine for each project.</p>

<p>Today, I was trying to use Zeus to speed up my Rspec test inside one of the Rails projects. I found this gem through a screencast by Ryan Bates about Fast Test.</p>

<p>Install Zeus is pretty easy, you just need to run this command on your terminal:</p>

<p><code>bash
gem install zeus
</code></p>

<p>After that you just need to go to the directory of your Rails app and start the Zeus server using this command:</p>

<p><code>bash
zeus start
</code></p>

<p>However, when I got an error when I was trying to ran that command. Here is the error:</p>

<p>``` bash
vagrant@precise32:/vagrant$ zeus start
Starting Zeus server
[ready] [crashed] [running] [connecting] [waiting]
boot
└── default_bundle</p>

<pre><code>├── development_environment
│   └── prerake
└── test_environment
    ├── cucumber_environment
    └── test_helper
</code></pre>

<p>Available Commands: [waiting] [crashed] [ready]
zeus rake
zeus runner (alias: r)
zeus console (alias: c)
zeus server (alias: s)
zeus generate (alias: g)
zeus destroy (alias: d)
zeus dbconsole
zeus cucumber
zeus test (alias: rspec, testrb)
It looks like Zeus is already running. If not, remove .zeus.sock and try again.
```</p>

<p>You can see on the last line that it&rsquo;s complaining something about .zeus.sock. The solution is pretty easy, you just need to add environment variable to your Vagrant machine. Use this command to add environment variable:</p>

<p><code>bash
export ZEUSSOCK=/tmp/zeus.sock
</code></p>

<p>Also make sure you use the latest version of Zeus. Add this line inside your Gemfile:</p>

<p>``` ruby</p>

<h1>Use Zeus</h1>

<p>gem &lsquo;zeus&rsquo;, &ldquo;>= 0.13.4.pre2&rdquo;
```</p>

<p>Run &lsquo;bundle&rsquo; to install the gem and update the version. You should be able to run &lsquo;zeus start&rsquo; now and other Rails commands.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails set up namespace and redirect from namespace]]></title>
    <link href="http://blog.rudylee.com/2012/02/12/rails-set-up-namespace-and-redirect-from-namespace/"/>
    <updated>2012-02-12T13:02:27+11:00</updated>
    <id>http://blog.rudylee.com/2012/02/12/rails-set-up-namespace-and-redirect-from-namespace</id>
    <content type="html"><![CDATA[<p>In order to differentiate between admin actions and users actions, you can set up what called &ldquo;namespace&rdquo; in your rails apps. The basic idea of this feature is you will have different controller and view files for each role in your application.</p>

<p>This concept is similar with prefixes in CakePHP. However,  CakePHP allows you to put different action in one controller file, while in rails you have to create different controller and view file for the new namespace. Here is the sample namespace code that I put in my routes.rb file :</p>

<p><code>ruby
namespace :admin do
  resources :users
  resources :products
  resources :categories
end
</code></p>

<p>The code means that users, products and categories will have admin namespace. The next step is to create new folder in your controller and view folder called &ldquo;admin&rdquo;. Here is the screenshot ( see the directory browser on the left hand side ) :</p>

<p><a href="http://blog.rudylee.com/wp-content/uploads/2012/04/routes-rb.png"><img src="http://blog.rudylee.com/wp-content/uploads/2012/04/routes-rb.png" alt="" /></a></p>

<p>Put the template and controller files inside these folders. You have to add Admin:: in front of the class definition of your controller file. So it&rsquo;s gonna be like this :</p>

<p>``` ruby</p>

<pre><code>class Admin::UsersController &lt; ApplicationController
</code></pre>

<p>```</p>

<p>After you set up everything done, you can try to access your apps through <a href="http://your-url/admin/controller-path">http://your-url/admin/controller-path</a> ( ex: <a href="http://localhost:3000/admin/users">http://localhost:3000/admin/users</a> ). It should automatically pick the controller and view files from admin folder. And if you want to redirect to the original route, you have to add &lsquo;/&rsquo; in front of the controller name. Here is the code :</p>

<p>``` ruby</p>

<pre><code>redirect_to :controller =&gt; "/sessions",:action =&gt; "new"
</code></pre>

<p>```</p>

<p>It means you will redirect the user to session controller outside of the namespace and load &ldquo;new&rdquo; action. That&rsquo;s all.</p>
]]></content>
  </entry>
  
</feed>
